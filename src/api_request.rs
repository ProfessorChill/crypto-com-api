//! Request handler for the API Requests.

use crate::prelude::*;
use crate::utils::get_epoch_ms;

use serde::Serialize;

/// The request format for sending data to crypto.com
///
/// This is created for all requests sent.
#[derive(Clone, Serialize, Debug)]
pub struct ApiRequest {
    /// The ID of the crypto.com request, the response will contain the same ID.
    pub id: Option<u64>,
    /// The method the be invoked refer to [crypto.com docs](https://exchange-docs.crypto.com/spot/index.html)
    pub method: String,
    /// Params that are needed by the method as a json value.
    pub params: Option<serde_json::Value>,
    /// Your API key as needed.
    pub api_key: Option<String>,
    /// The signature generated by digital_signature.
    sig: Option<String>,
    /// The send nonce of the request.
    pub nonce: Option<u64>,
}

/// Builder for [`ApiRequest`]
#[derive(Default, Debug)]
pub struct ApiRequestBuilder {
    /// The ID of the crypto.com request, the response will contain the same ID.
    pub id: Option<u64>,
    /// The method the be invoked refer to [crypto.com docs](https://exchange-docs.crypto.com/spot/index.html)
    pub method: String,
    /// Params that are needed by the method as a json value.
    pub params: Option<serde_json::Value>,
    /// Your API key as needed.
    pub api_key: Option<String>,
    /// The signature generated by digital_signature.
    sig: Option<String>,
    /// The send nonce of the request.
    pub nonce: Option<u64>,
}

impl ApiRequestBuilder {
    /// With id.
    #[must_use]
    pub const fn with_id(mut self, id: u64) -> Self {
        self.id = Some(id);
        self
    }

    /// With method.
    #[must_use]
    pub fn with_method(mut self, method: impl Into<String>) -> Self {
        self.method = method.into();
        self
    }

    /// With params.
    #[must_use]
    pub fn with_params(mut self, params: impl Serialize) -> Self {
        self.params = Some(serde_json::json!(params));
        self
    }

    /// With API Key.
    #[must_use]
    pub fn with_api_key(mut self, api_key: impl Into<String>) -> Self {
        self.api_key = Some(api_key.into());
        self
    }

    /// Creates the digital signature needed for private requests.
    ///
    /// [Digital Signature](https://exchange-docs.crypto.com/spot/index.html#digital-signature)
    #[must_use]
    pub fn with_digital_signature(mut self, secret: impl Into<String>) -> Self {
        let secret = secret.into();

        // Get the params as key + value (no spaces, no delimiters).
        let param_str = self
            .params
            .as_ref()
            .map_or_else(String::new, crate::utils::params_to_str);

        // The payload format is method + id + api_key + parameter string + nonce.
        let mut payload_str = String::new();
        payload_str += &self.method;

        if let Some(id) = self.id {
            payload_str += &id.to_string();
        }

        if let Some(ref key) = self.api_key {
            payload_str += key;
        }

        payload_str += &param_str;

        if let Some(ref nonce) = self.nonce {
            payload_str += &nonce.to_string();
        }

        // As per the documentation we use HMAC-SHA256 and encode it to bytes, then hex encode it
        // as a string.
        let mut mac =
            HmacSha256::new_from_slice(secret.as_bytes()).expect("HMAC can take key of any size");
        mac.update(payload_str.as_bytes());
        let result = mac.finalize();
        let sig = result.into_bytes();

        self.sig = Some(hex::encode(sig));
        self
    }

    /// With nonce.
    #[must_use]
    pub fn with_nonce(mut self) -> Self {
        self.nonce = Some(get_epoch_ms());
        self
    }

    /// Build self into [`ApiRequest`]
    ///
    /// # Errors
    ///
    /// Will return [`ApiError`] if `method` is empty.
    pub fn build(self) -> Result<ApiRequest, ApiError> {
        if self.method.is_empty() {
            return Err(ApiError::InvalidApiRequest("method".to_owned()));
        }

        Ok(ApiRequest {
            id: self.id,
            method: self.method,
            params: self.params,
            api_key: self.api_key,
            sig: self.sig,
            nonce: self.nonce,
        })
    }
}
